package block_reordering_security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "log"
    "math"
    "sync"
    "time"
)

// Constants for encryption
const (
    keySize   = 32 // AES-256
    nonceSize = 12 // GCM standard nonce size
)

// Transaction represents a simplified blockchain transaction structure
type Transaction struct {
    ID        string    `json:"id"`
    Timestamp time.Time `json:"timestamp"`
    Amount    float64   `json:"amount"`
    From      string    `json:"from"`
    To        string    `json:"to"`
}

// Block represents a simplified blockchain block structure
type Block struct {
    ID          string        `json:"id"`
    Timestamp   time.Time     `json:"timestamp"`
    Transactions []Transaction `json:"transactions"`
    PreviousHash string        `json:"previous_hash"`
}

// AnomalyDetector handles the detection of anomalies in the blockchain
type AnomalyDetector struct {
    Transactions []Transaction
    Blocks       []Block
    lock         sync.Mutex
    alerts       chan string
}

// NewAnomalyDetector initializes a new AnomalyDetector
func NewAnomalyDetector() *AnomalyDetector {
    return &AnomalyDetector{
        Transactions: []Transaction{},
        Blocks:       []Block{},
        alerts:       make(chan string, 100),
    }
}

// AddTransaction adds a new transaction to the monitoring system
func (ad *AnomalyDetector) AddTransaction(tx Transaction) {
    ad.lock.Lock()
    defer ad.lock.Unlock()

    ad.Transactions = append(ad.Transactions, tx)
    if ad.detectAnomaly(tx) {
        alert := fmt.Sprintf("Anomaly detected in transaction: %s", tx.ID)
        ad.alerts <- alert
        log.Println(alert)
    }
}

// AddBlock adds a new block to the monitoring system
func (ad *AnomalyDetector) AddBlock(block Block) {
    ad.lock.Lock()
    defer ad.lock.Unlock()

    ad.Blocks = append(ad.Blocks, block)
    if ad.detectAnomalyInBlock(block) {
        alert := fmt.Sprintf("Anomaly detected in block: %s", block.ID)
        ad.alerts <- alert
        log.Println(alert)
    }
}

// detectAnomaly detects anomalies in a given transaction
func (ad *AnomalyDetector) detectAnomaly(tx Transaction) bool {
    // Implement anomaly detection logic, e.g., outlier detection on transaction amounts
    if tx.Amount > 1000000 { // Example threshold
        return true
    }
    return false
}

// detectAnomalyInBlock detects anomalies in a given block
func (ad *AnomalyDetector) detectAnomalyInBlock(block Block) bool {
    // Implement anomaly detection logic for blocks, e.g., unexpected sequence or timestamp issues
    if block.Timestamp.Before(time.Now().Add(-1 * time.Hour)) {
        return true
    }
    return false
}

// EncryptData encrypts the data using AES GCM
func EncryptData(plaintext []byte, key []byte) (string, error) {
    if len(key) != keySize {
        return "", errors.New("invalid key size")
    }

    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }

    nonce := make([]byte, nonceSize)
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    aesgcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    ciphertext := aesgcm.Seal(nil, nonce, plaintext, nil)
    result := append(nonce, ciphertext...)
    return base64.StdEncoding.EncodeToString(result), nil
}

// DecryptData decrypts the data using AES GCM
func DecryptData(ciphertext string, key []byte) ([]byte, error) {
    if len(key) != keySize {
        return nil, errors.New("invalid key size")
    }

    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return nil, err
    }

    if len(data) < nonceSize {
        return nil, errors.New("ciphertext too short")
    }

    nonce, ciphertext := data[:nonceSize], data[nonceSize:]

    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    aesgcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    return aesgcm.Open(nil, nonce, ciphertext, nil)
}

// HashData hashes the data using SHA-256
func HashData(data []byte) []byte {
    hash := sha256.Sum256(data)
    return hash[:]
}

// GetAlerts retrieves the latest alerts
func (ad *AnomalyDetector) GetAlerts() []string {
    ad.lock.Lock()
    defer ad.lock.Unlock()

    var alerts []string
    for len(ad.alerts) > 0 {
        alerts = append(alerts, <-ad.alerts)
    }
    return alerts
}

// SaveState saves the current state of the anomaly detector to a file
func (ad *AnomalyDetector) SaveState(filename string) error {
    ad.lock.Lock()
    defer ad.lock.Unlock()

    data, err := json.Marshal(ad)
    if err != nil {
        return err
    }

    encryptedData, err := EncryptData(data, []byte("examplekey123456789012345678")) // Example key, should be securely managed
    if err != nil {
        return err
    }

    return ioutil.WriteFile(filename, []byte(encryptedData), 0600)
}

// LoadState loads the state of the anomaly detector from a file
func (ad *AnomalyDetector) LoadState(filename string) error {
    ad.lock.Lock()
    defer ad.lock.Unlock()

    encryptedData, err := ioutil.ReadFile(filename)
    if err != nil {
        return err
    }

    data, err := DecryptData(string(encryptedData), []byte("examplekey123456789012345678")) // Example key, should be securely managed
    if err != nil {
        return err
    }

    return json.Unmarshal(data, ad)
}
