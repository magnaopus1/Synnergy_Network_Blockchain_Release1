package block_reordering_security

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"time"
)

// Block represents a single block in the blockchain
type Block struct {
	Index        int
	Timestamp    time.Time
	PreviousHash string
	Hash         string
	Data         string
	Nonce        int
}

// Blockchain represents the blockchain structure with additional security features
type Blockchain struct {
	Blocks            []Block
	FinalityThreshold int // Number of confirmations required for finality
}

// NewBlockchain initializes a new blockchain with a genesis block
func NewBlockchain() *Blockchain {
	bc := &Blockchain{
		Blocks:            []Block{createGenesisBlock()},
		FinalityThreshold: 6, // default finality threshold
	}
	return bc
}

// createGenesisBlock creates the initial block in the blockchain
func createGenesisBlock() Block {
	return Block{
		Index:        0,
		Timestamp:    time.Now(),
		PreviousHash: "0",
		Hash:         calculateHash(0, time.Now(), "0", "", 0),
		Data:         "Genesis Block",
		Nonce:        0,
	}
}

// calculateHash computes the SHA-256 hash of the block's contents
func calculateHash(index int, timestamp time.Time, previousHash, data string, nonce int) string {
	record := string(index) + timestamp.String() + previousHash + data + string(nonce)
	hash := sha256.New()
	hash.Write([]byte(record))
	return hex.EncodeToString(hash.Sum(nil))
}

// AddBlock adds a new block to the blockchain after validation
func (bc *Blockchain) AddBlock(data string) error {
	previousBlock := bc.Blocks[len(bc.Blocks)-1]
	newBlock, err := mineBlock(previousBlock, data)
	if err != nil {
		return err
	}
	if isValidNewBlock(newBlock, previousBlock) {
		bc.Blocks = append(bc.Blocks, newBlock)
		return nil
	}
	return errors.New("failed to add block: invalid block")
}

// mineBlock creates a new block by solving a proof-of-work puzzle
func mineBlock(previousBlock Block, data string) (Block, error) {
	var newBlock Block
	var nonce int
	for {
		newBlock = Block{
			Index:        previousBlock.Index + 1,
			Timestamp:    time.Now(),
			PreviousHash: previousBlock.Hash,
			Data:         data,
			Nonce:        nonce,
		}
		newBlock.Hash = calculateHash(newBlock.Index, newBlock.Timestamp, newBlock.PreviousHash, newBlock.Data, newBlock.Nonce)
		if isValidHash(newBlock.Hash) {
			break
		}
		nonce++
	}
	return newBlock, nil
}

// isValidHash checks if the hash meets the difficulty target
func isValidHash(hash string) bool {
	// Simple difficulty target check (could be more complex in a real system)
	return hash[:4] == "0000"
}

// isValidNewBlock verifies the integrity and correctness of a new block
func isValidNewBlock(newBlock, previousBlock Block) bool {
	if previousBlock.Index+1 != newBlock.Index {
		return false
	}
	if previousBlock.Hash != newBlock.PreviousHash {
		return false
	}
	if calculateHash(newBlock.Index, newBlock.Timestamp, newBlock.PreviousHash, newBlock.Data, newBlock.Nonce) != newBlock.Hash {
		return false
	}
	return true
}

// ValidateChain validates the integrity of the entire blockchain
func (bc *Blockchain) ValidateChain() bool {
	for i := 1; i < len(bc.Blocks); i++ {
		if !isValidNewBlock(bc.Blocks[i], bc.Blocks[i-1]) {
			return false
		}
	}
	return true
}

// EnsureFinality checks if a block is final based on the number of confirmations
func (bc *Blockchain) EnsureFinality(blockIndex int) bool {
	if len(bc.Blocks) <= blockIndex {
		return false
	}
	// A block is considered final if it has at least `FinalityThreshold` confirmations
	return (len(bc.Blocks) - blockIndex - 1) >= bc.FinalityThreshold
}

// SequenceValidation ensures that all blocks are in the correct order
func (bc *Blockchain) SequenceValidation() bool {
	for i := 1; i < len(bc.Blocks); i++ {
		if bc.Blocks[i].Index != bc.Blocks[i-1].Index+1 {
			return false
		}
	}
	return true
}

// DetectAndPreventReordering checks and prevents block reordering attacks
func (bc *Blockchain) DetectAndPreventReordering() error {
	if !bc.SequenceValidation() {
		return errors.New("block reordering detected")
	}
	if !bc.ValidateChain() {
		return errors.New("blockchain integrity compromised")
	}
	return nil
}

// SecureNodeCommunication secures communication between nodes using encryption
func SecureNodeCommunication(data []byte) ([]byte, error) {
	// Placeholder for encryption logic, e.g., AES or Scrypt with proper key management
	return data, nil
}

// DecryptNodeCommunication decrypts data received from nodes
func DecryptNodeCommunication(encryptedData []byte) ([]byte, error) {
	// Placeholder for decryption logic
	return encryptedData, nil
}

// PreventSybilAttacks implements mechanisms to prevent Sybil attacks
func (bc *Blockchain) PreventSybilAttacks() {
	// Implement identity verification, reputation systems, etc.
}
