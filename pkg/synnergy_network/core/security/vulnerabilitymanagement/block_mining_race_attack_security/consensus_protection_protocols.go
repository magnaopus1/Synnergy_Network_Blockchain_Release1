package block_mining_race_attack_security

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"log"
	"time"

	"golang.org/x/crypto/scrypt"
)

// ConsensusProtectionProtocols provides mechanisms to enhance the security of consensus protocols against race attacks.
type ConsensusProtectionProtocols struct {
	Nodes            []Node
	ProtocolSettings ProtocolSettings
}

// Node represents a participant in the blockchain network.
type Node struct {
	ID           string
	PublicKey    []byte
	Reputation   int
	LastBlockID  string
	LastBlockTime time.Time
}

// ProtocolSettings contains configurable settings for the consensus protocol.
type ProtocolSettings struct {
	MinReputation    int
	MaxBlockTimeDiff time.Duration
	HashDifficulty   int
}

// NewConsensusProtectionProtocols initializes a new ConsensusProtectionProtocols instance with default settings.
func NewConsensusProtectionProtocols(nodes []Node) *ConsensusProtectionProtocols {
	return &ConsensusProtectionProtocols{
		Nodes: nodes,
		ProtocolSettings: ProtocolSettings{
			MinReputation:    10,
			MaxBlockTimeDiff: 5 * time.Minute,
			HashDifficulty:   16,
		},
	}
}

// VerifyBlock verifies if a block meets the required conditions.
func (cpp *ConsensusProtectionProtocols) VerifyBlock(node Node, blockID string, blockTime time.Time) error {
	if node.Reputation < cpp.ProtocolSettings.MinReputation {
		return errors.New("node reputation too low to participate in consensus")
	}

	if time.Since(blockTime) > cpp.ProtocolSettings.MaxBlockTimeDiff {
		return errors.New("block time difference exceeds maximum allowed limit")
	}

	// Simulated hash check (placeholder for actual block verification logic)
	hash := cpp.simulateHash(blockID)
	if !cpp.checkHashDifficulty(hash) {
		return errors.New("block hash does not meet difficulty requirements")
	}

	// Update node's last block info
	node.LastBlockID = blockID
	node.LastBlockTime = blockTime
	return nil
}

// simulateHash simulates a hashing process, returning a pseudo-random hash for a given input.
func (cpp *ConsensusProtectionProtocols) simulateHash(input string) string {
	hash := make([]byte, 32)
	_, err := rand.Read(hash)
	if err != nil {
		log.Fatal(err)
	}
	return hex.EncodeToString(hash)
}

// checkHashDifficulty checks if the hash meets the difficulty criteria.
func (cpp *ConsensusProtectionProtocols) checkHashDifficulty(hash string) bool {
	// Placeholder for real hash difficulty check (e.g., leading zeros)
	return len(hash) > cpp.ProtocolSettings.HashDifficulty
}

// SecureCommunication encrypts messages between nodes using Scrypt for key derivation.
func (cpp *ConsensusProtectionProtocols) SecureCommunication(message, salt, passphrase string) (string, error) {
	key, err := scrypt.Key([]byte(passphrase), []byte(salt), 1<<15, 8, 1, 32)
	if err != nil {
		return "", err
	}

	// Placeholder for actual encryption using the derived key (e.g., AES encryption)
	encryptedMessage := hex.EncodeToString(key) + message
	return encryptedMessage, nil
}

