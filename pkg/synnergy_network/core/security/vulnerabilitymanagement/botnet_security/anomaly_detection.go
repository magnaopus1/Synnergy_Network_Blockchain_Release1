package botnet_security

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
	"log"
	"net"
	"sync"
	"time"
)

// Configuration and constants
const (
	EncryptionKey     = "32-byte-long-key-for-encryption" // Use environment variables or secure storage in real implementations
	DetectionInterval = time.Minute * 5
	MaxRequestsPerIP  = 100
)

// AnomalyDetector is responsible for detecting unusual network activities that may indicate a botnet.
type AnomalyDetector struct {
	mu            sync.Mutex
	requestCounts map[string]int
	blockedIPs    map[string]time.Time
	trafficData   map[string][]byte
}

// NewAnomalyDetector creates a new instance of AnomalyDetector.
func NewAnomalyDetector() *AnomalyDetector {
	return &AnomalyDetector{
		requestCounts: make(map[string]int),
		blockedIPs:    make(map[string]time.Time),
		trafficData:   make(map[string][]byte),
	}
}

// TrackTraffic records incoming traffic and checks for anomalies.
func (ad *AnomalyDetector) TrackTraffic(ip string, data []byte) {
	ad.mu.Lock()
	defer ad.mu.Unlock()

	if _, blocked := ad.blockedIPs[ip]; blocked {
		log.Printf("Blocked traffic from IP: %s", ip)
		return
	}

	ad.requestCounts[ip]++
	ad.trafficData[ip] = append(ad.trafficData[ip], data...)

	if ad.requestCounts[ip] > MaxRequestsPerIP {
		log.Printf("Anomaly detected: Too many requests from IP %s", ip)
		ad.blockIP(ip)
	}

	if anomalyDetected := ad.analyzeTraffic(ip); anomalyDetected {
		ad.blockIP(ip)
	}
}

// analyzeTraffic inspects the traffic data to detect unusual patterns.
func (ad *AnomalyDetector) analyzeTraffic(ip string) bool {
	// Implement machine learning or heuristic-based anomaly detection algorithms.
	// Placeholder logic: check for sudden spikes in traffic data length
	trafficLength := len(ad.trafficData[ip])
	if trafficLength > 1024*MaxRequestsPerIP {
		log.Printf("Unusual traffic pattern detected from IP: %s", ip)
		return true
	}
	return false
}

// blockIP blocks the given IP address for a set period.
func (ad *AnomalyDetector) blockIP(ip string) {
	ad.blockedIPs[ip] = time.Now().Add(DetectionInterval)
	delete(ad.requestCounts, ip)
	delete(ad.trafficData, ip)
	log.Printf("IP blocked: %s", ip)
}

// periodicCleanup removes old entries and blocks that have expired.
func (ad *AnomalyDetector) periodicCleanup() {
	ticker := time.NewTicker(time.Hour)
	defer ticker.Stop()

	for range ticker.C {
		ad.mu.Lock()
		now := time.Now()
		for ip, unblockTime := range ad.blockedIPs {
			if now.After(unblockTime) {
				delete(ad.blockedIPs, ip)
			}
		}
		ad.mu.Unlock()
	}
}

// Encrypt encrypts data using AES-GCM.
func Encrypt(plaintext []byte, key string) (string, error) {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return "", err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt decrypts AES-GCM encrypted data.
func Decrypt(ciphertext string, key string) ([]byte, error) {
	data, err := base64.StdEncoding.DecodeString(ciphertext)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := aesGCM.NonceSize()
	if len(data) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := data[:nonceSize], data[nonceSize:]
	return aesGCM.Open(nil, nonce, ciphertext, nil)
}

func main() {
	// For real-world use, remove or replace with proper initialization and cleanup routines
	ad := NewAnomalyDetector()
	go ad.periodicCleanup()

	// Example usage:
	ip := "192.168.1.1"
	data := []byte("example traffic data")
	ad.TrackTraffic(ip, data)

	encryptedData, err := Encrypt(data, EncryptionKey)
	if err != nil {
		log.Fatalf("Encryption error: %v", err)
	}
	log.Printf("Encrypted data: %s", encryptedData)

	decryptedData, err := Decrypt(encryptedData, EncryptionKey)
	if err != nil {
		log.Fatalf("Decryption error: %v", err)
	}
	log.Printf("Decrypted data: %s", decryptedData)
}
