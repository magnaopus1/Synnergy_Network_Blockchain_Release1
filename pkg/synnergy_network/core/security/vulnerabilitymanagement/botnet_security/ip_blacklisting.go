package botnet_security

import (
    "net"
    "sync"
    "time"
)

// IPBlacklistManager handles the IP blacklisting operations.
type IPBlacklistManager struct {
    blacklist map[string]time.Time
    mu        sync.RWMutex
    duration  time.Duration
}

// NewIPBlacklistManager initializes a new IPBlacklistManager.
func NewIPBlacklistManager(duration time.Duration) *IPBlacklistManager {
    return &IPBlacklistManager{
        blacklist: make(map[string]time.Time),
        duration:  duration,
    }
}

// AddToBlacklist adds an IP address to the blacklist.
func (m *IPBlacklistManager) AddToBlacklist(ip string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.blacklist[ip] = time.Now().Add(m.duration)
}

// RemoveFromBlacklist removes an IP address from the blacklist.
func (m *IPBlacklistManager) RemoveFromBlacklist(ip string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    delete(m.blacklist, ip)
}

// IsBlacklisted checks if an IP address is blacklisted.
func (m *IPBlacklistManager) IsBlacklisted(ip string) bool {
    m.mu.RLock()
    defer m.mu.RUnlock()
    expiry, exists := m.blacklist[ip]
    if !exists {
        return false
    }
    if time.Now().After(expiry) {
        m.RemoveFromBlacklist(ip)
        return false
    }
    return true
}

// CleanupExpiredEntries cleans up expired IP entries from the blacklist.
func (m *IPBlacklistManager) CleanupExpiredEntries() {
    m.mu.Lock()
    defer m.mu.Unlock()
    for ip, expiry := range m.blacklist {
        if time.Now().After(expiry) {
            delete(m.blacklist, ip)
        }
    }
}

// ValidateIP checks if the given string is a valid IP address.
func (m *IPBlacklistManager) ValidateIP(ip string) bool {
    return net.ParseIP(ip) != nil
}

// PeriodicCleanup runs the cleanup process at specified intervals.
func (m *IPBlacklistManager) PeriodicCleanup(interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    for range ticker.C {
        m.CleanupExpiredEntries()
    }
}
