package botnet_security

import (
	"net"
	"log"
	"os"
	"strings"
	"time"
	"sync"
)

// BotnetTrafficAnalyzer analyzes network traffic for botnet activities
type BotnetTrafficAnalyzer struct {
	whitelist []net.IPNet
	blacklist []net.IPNet
	alertChan chan<- string
	mu        sync.Mutex
}

// NewBotnetTrafficAnalyzer creates a new instance of BotnetTrafficAnalyzer
func NewBotnetTrafficAnalyzer(alertChan chan<- string) *BotnetTrafficAnalyzer {
	return &BotnetTrafficAnalyzer{
		whitelist: []net.IPNet{},
		blacklist: []net.IPNet{},
		alertChan: alertChan,
	}
}

// AddToWhitelist adds an IP address to the whitelist
func (analyzer *BotnetTrafficAnalyzer) AddToWhitelist(cidr string) error {
	_, network, err := net.ParseCIDR(cidr)
	if err != nil {
		return err
	}
	analyzer.mu.Lock()
	analyzer.whitelist = append(analyzer.whitelist, *network)
	analyzer.mu.Unlock()
	return nil
}

// AddToBlacklist adds an IP address to the blacklist
func (analyzer *BotnetTrafficAnalyzer) AddToBlacklist(cidr string) error {
	_, network, err := net.ParseCIDR(cidr)
	if err != nil {
		return err
	}
	analyzer.mu.Lock()
	analyzer.blacklist = append(analyzer.blacklist, *network)
	analyzer.mu.Unlock()
	return nil
}

// IsWhitelisted checks if an IP is whitelisted
func (analyzer *BotnetTrafficAnalyzer) IsWhitelisted(ip net.IP) bool {
	analyzer.mu.Lock()
	defer analyzer.mu.Unlock()
	for _, network := range analyzer.whitelist {
		if network.Contains(ip) {
			return true
		}
	}
	return false
}

// IsBlacklisted checks if an IP is blacklisted
func (analyzer *BotnetTrafficAnalyzer) IsBlacklisted(ip net.IP) bool {
	analyzer.mu.Lock()
	defer analyzer.mu.Unlock()
	for _, network := range analyzer.blacklist {
		if network.Contains(ip) {
			return true
		}
	}
	return false
}

// AnalyzeTraffic monitors network traffic and detects potential botnet activities
func (analyzer *BotnetTrafficAnalyzer) AnalyzeTraffic() {
	for {
		// Simulated traffic analysis logic
		time.Sleep(1 * time.Second)
		simulatedIP := net.ParseIP("192.0.2.1")
		if analyzer.IsBlacklisted(simulatedIP) {
			analyzer.alertChan <- "Suspicious activity detected from blacklisted IP: " + simulatedIP.String()
		}
	}
}

// AlertHandler handles alerts generated by the traffic analyzer
func AlertHandler(alertChan <-chan string) {
	for alert := range alertChan {
		log.Println("ALERT:", alert)
		// Additional handling logic (e.g., notify admin, block IP)
	}
}

// LogToFile logs traffic analysis events to a file
func LogToFile(filename string) (*os.File, error) {
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		return nil, err
	}
	log.SetOutput(file)
	return file, nil
}

// LoadWhitelistFromFile loads whitelisted IPs from a file
func (analyzer *BotnetTrafficAnalyzer) LoadWhitelistFromFile(filepath string) error {
	file, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer file.Close()
	
	var cidr string
	for {
		_, err := fmt.Fscanln(file, &cidr)
		if err != nil {
			break
		}
		analyzer.AddToWhitelist(cidr)
	}
	return nil
}

// LoadBlacklistFromFile loads blacklisted IPs from a file
func (analyzer *BotnetTrafficAnalyzer) LoadBlacklistFromFile(filepath string) error {
	file, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer file.Close()
	
	var cidr string
	for {
		_, err := fmt.Fscanln(file, &cidr)
		if err != nil {
			break
		}
		analyzer.AddToBlacklist(cidr)
	}
	return nil
}
