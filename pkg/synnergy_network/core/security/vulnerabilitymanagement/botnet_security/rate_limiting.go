package botnet_security

import (
	"time"
	"crypto/sha256"
	"encoding/hex"
	"sync"
)

// RequestLimiter struct to manage rate limiting
type RequestLimiter struct {
	mu             sync.Mutex
	clients        map[string]*ClientData
	requestLimit   int
	windowDuration time.Duration
}

// ClientData struct holds request data for a client
type ClientData struct {
	requestCount int
	firstRequest time.Time
}

// NewRequestLimiter initializes a new RequestLimiter
func NewRequestLimiter(requestLimit int, windowDuration time.Duration) *RequestLimiter {
	return &RequestLimiter{
		clients:        make(map[string]*ClientData),
		requestLimit:   requestLimit,
		windowDuration: windowDuration,
	}
}

// GetClientKey generates a unique key for the client based on IP or other unique identifiers
func GetClientKey(identifier string) string {
	hash := sha256.New()
	hash.Write([]byte(identifier))
	return hex.EncodeToString(hash.Sum(nil))
}

// IsRateLimited checks if a client has exceeded the rate limit
func (rl *RequestLimiter) IsRateLimited(clientIdentifier string) bool {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	clientKey := GetClientKey(clientIdentifier)
	clientData, exists := rl.clients[clientKey]

	if !exists {
		rl.clients[clientKey] = &ClientData{
			requestCount: 1,
			firstRequest: time.Now(),
		}
		return false
	}

	if time.Since(clientData.firstRequest) > rl.windowDuration {
		clientData.requestCount = 1
		clientData.firstRequest = time.Now()
		return false
	}

	if clientData.requestCount >= rl.requestLimit {
		return true
	}

	clientData.requestCount++
	return false
}

// CleanupOldEntries removes outdated client entries to manage memory usage
func (rl *RequestLimiter) CleanupOldEntries() {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	for key, clientData := range rl.clients {
		if time.Since(clientData.firstRequest) > rl.windowDuration {
			delete(rl.clients, key)
		}
	}
}

// RunCleanupRoutine periodically cleans up old entries
func (rl *RequestLimiter) RunCleanupRoutine(interval time.Duration) {
	ticker := time.NewTicker(interval)
	for range ticker.C {
		rl.CleanupOldEntries()
	}
}
