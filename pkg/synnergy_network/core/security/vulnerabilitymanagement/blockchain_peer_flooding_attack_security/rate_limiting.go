package blockchain_peer_flooding_attack_security

import (
    "fmt"
    "sync"
    "time"
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "io"
)

// Constants
const (
    MaxRequestsPerMinute = 60
    BlockDuration        = time.Hour
)

// Struct to store peer information
type PeerInfo struct {
    LastRequestTime time.Time
    RequestCount    int
    IsBlocked       bool
    BlockedUntil    time.Time
    IP              string
}

// RateLimiter struct for managing peer rate limits
type RateLimiter struct {
    Peers   map[string]*PeerInfo
    Mutex   sync.Mutex
    Blocked map[string]time.Time
    AESKey  []byte // Key for encryption
}

// InitializeRateLimiter initializes the rate limiter
func InitializeRateLimiter(aesKey []byte) *RateLimiter {
    return &RateLimiter{
        Peers:   make(map[string]*PeerInfo),
        Blocked: make(map[string]time.Time),
        AESKey:  aesKey,
    }
}

// CheckRateLimit checks if a peer has exceeded the rate limit
func (rl *RateLimiter) CheckRateLimit(ip string) bool {
    rl.Mutex.Lock()
    defer rl.Mutex.Unlock()

    now := time.Now()
    peer, exists := rl.Peers[ip]
    if !exists {
        peer = &PeerInfo{LastRequestTime: now, RequestCount: 1, IP: ip}
        rl.Peers[ip] = peer
        return true
    }

    if peer.IsBlocked && now.Before(peer.BlockedUntil) {
        return false // Peer is currently blocked
    }

    if now.Sub(peer.LastRequestTime) > time.Minute {
        peer.RequestCount = 0 // Reset counter after a minute
    }

    peer.LastRequestTime = now
    peer.RequestCount++

    if peer.RequestCount > MaxRequestsPerMinute {
        peer.IsBlocked = true
        peer.BlockedUntil = now.Add(BlockDuration)
        rl.Blocked[ip] = peer.BlockedUntil
        fmt.Printf("Peer %s blocked until %s\n", ip, peer.BlockedUntil)
        return false
    }

    return true
}

// EncryptData encrypts sensitive data using AES
func (rl *RateLimiter) EncryptData(data []byte) ([]byte, error) {
    block, err := aes.NewCipher(rl.AESKey)
    if err != nil {
        return nil, err
    }
    ciphertext := make([]byte, aes.BlockSize+len(data))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return nil, err
    }
    stream := cipher.NewCFBEncrypter(block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], data)
    return ciphertext, nil
}

// DecryptData decrypts data encrypted with AES
func (rl *RateLimiter) DecryptData(ciphertext []byte) ([]byte, error) {
    block, err := aes.NewCipher(rl.AESKey)
    if err != nil {
        return nil, err
    }
    if len(ciphertext) < aes.BlockSize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]
    stream := cipher.NewCFBDecrypter(block, iv)
    stream.XORKeyStream(ciphertext, ciphertext)
    return ciphertext, nil
}

// MonitorBlockedPeers monitors and unblocks peers after the block duration
func (rl *RateLimiter) MonitorBlockedPeers() {
    for {
        time.Sleep(time.Minute)
        rl.Mutex.Lock()
        now := time.Now()
        for ip, unblockTime := range rl.Blocked {
            if now.After(unblockTime) {
                delete(rl.Blocked, ip)
                peer := rl.Peers[ip]
                peer.IsBlocked = false
                peer.RequestCount = 0
                fmt.Printf("Peer %s unblocked\n", ip)
            }
        }
        rl.Mutex.Unlock()
    }
}
