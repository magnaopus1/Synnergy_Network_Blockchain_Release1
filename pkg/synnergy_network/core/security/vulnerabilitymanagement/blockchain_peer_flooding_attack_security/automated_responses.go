package blockchain_peer_flooding_attack_security

import (
    "fmt"
    "net"
    "sync"
    "time"
)

// Struct to hold peer information
type Peer struct {
    IP            string
    LastActivity  time.Time
    ConnectionCount int
    ReputationScore int
}

// Struct for managing the network state
type NetworkManager struct {
    Peers          map[string]*Peer
    RateLimit      int
    Mutex          sync.Mutex
    TrafficMonitor chan net.Conn
    BlockList      map[string]bool
}

// InitializeNetworkManager initializes the network manager
func InitializeNetworkManager(rateLimit int) *NetworkManager {
    return &NetworkManager{
        Peers:          make(map[string]*Peer),
        RateLimit:      rateLimit,
        TrafficMonitor: make(chan net.Conn),
        BlockList:      make(map[string]bool),
    }
}

// MonitorTraffic starts monitoring network traffic
func (nm *NetworkManager) MonitorTraffic() {
    for conn := range nm.TrafficMonitor {
        go nm.HandleConnection(conn)
    }
}

// HandleConnection processes each incoming connection
func (nm *NetworkManager) HandleConnection(conn net.Conn) {
    defer conn.Close()
    ip := conn.RemoteAddr().String()

    nm.Mutex.Lock()
    peer, exists := nm.Peers[ip]
    if !exists {
        peer = &Peer{
            IP:            ip,
            LastActivity:  time.Now(),
            ConnectionCount: 0,
            ReputationScore: 100, // Starting reputation score
        }
        nm.Peers[ip] = peer
    }
    peer.LastActivity = time.Now()
    peer.ConnectionCount++
    nm.Mutex.Unlock()

    if nm.isFlooding(peer) {
        nm.BlockPeer(peer)
        return
    }

    nm.AnalyzeTraffic(conn, peer)
}

// isFlooding checks if a peer is flooding the network
func (nm *NetworkManager) isFlooding(peer *Peer) bool {
    if peer.ConnectionCount > nm.RateLimit {
        peer.ReputationScore -= 10
        return true
    }
    return false
}

// BlockPeer blocks a malicious peer
func (nm *NetworkManager) BlockPeer(peer *Peer) {
    nm.Mutex.Lock()
    defer nm.Mutex.Unlock()
    nm.BlockList[peer.IP] = true
    fmt.Printf("Peer %s blocked for flooding\n", peer.IP)
}

// AnalyzeTraffic analyzes the network traffic for patterns
func (nm *NetworkManager) AnalyzeTraffic(conn net.Conn, peer *Peer) {
    // Placeholder for traffic analysis logic
    // Example: Read data from the connection, check patterns, etc.
}

// UnblockPeer unblocks a previously blocked peer
func (nm *NetworkManager) UnblockPeer(ip string) {
    nm.Mutex.Lock()
    defer nm.Mutex.Unlock()
    delete(nm.BlockList, ip)
    fmt.Printf("Peer %s unblocked\n", ip)
}

// UpdateReputation updates the reputation score of a peer
func (nm *NetworkManager) UpdateReputation(ip string, scoreDelta int) {
    nm.Mutex.Lock()
    defer nm.Mutex.Unlock()
    if peer, exists := nm.Peers[ip]; exists {
        peer.ReputationScore += scoreDelta
        if peer.ReputationScore < 0 {
            peer.ReputationScore = 0
        }
    }
}
