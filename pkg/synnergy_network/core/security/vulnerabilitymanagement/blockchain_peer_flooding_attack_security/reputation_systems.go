package blockchain_peer_flooding_attack_security

import (
    "crypto/sha256"
    "encoding/hex"
    "sync"
    "time"
)

// ReputationManager manages the reputation scores of peers in the network.
type ReputationManager struct {
    peers      map[string]*Peer
    mutex      sync.Mutex
    threshold  int
    maxRetries int
}

// Peer represents a peer in the network with a reputation score.
type Peer struct {
    ID              string
    ReputationScore int
    LastActivity    time.Time
    Attempts        int
}

// NewReputationManager initializes a new ReputationManager.
func NewReputationManager(threshold, maxRetries int) *ReputationManager {
    return &ReputationManager{
        peers:      make(map[string]*Peer),
        threshold:  threshold,
        maxRetries: maxRetries,
    }
}

// GetPeer retrieves a peer from the ReputationManager.
func (rm *ReputationManager) GetPeer(id string) *Peer {
    rm.mutex.Lock()
    defer rm.mutex.Unlock()
    if peer, exists := rm.peers[id]; exists {
        return peer
    }
    return nil
}

// UpdateReputation updates the reputation score of a peer.
func (rm *ReputationManager) UpdateReputation(id string, delta int) {
    rm.mutex.Lock()
    defer rm.mutex.Unlock()
    peer, exists := rm.peers[id]
    if !exists {
        peer = &Peer{ID: id, ReputationScore: 0, LastActivity: time.Now()}
        rm.peers[id] = peer
    }
    peer.ReputationScore += delta
    peer.LastActivity = time.Now()
}

// BlockPeer temporarily blocks a peer from the network based on reputation score.
func (rm *ReputationManager) BlockPeer(id string) {
    rm.mutex.Lock()
    defer rm.mutex.Unlock()
    if peer, exists := rm.peers[id]; exists {
        peer.ReputationScore = -rm.threshold
    }
}

// ShouldThrottle checks if a peer's activity should be throttled based on reputation.
func (rm *ReputationManager) ShouldThrottle(id string) bool {
    rm.mutex.Lock()
    defer rm.mutex.Unlock()
    if peer, exists := rm.peers[id]; exists {
        return peer.ReputationScore <= -rm.threshold
    }
    return false
}

// IncrementAttempts increments the attempt counter for a peer and blocks if necessary.
func (rm *ReputationManager) IncrementAttempts(id string) {
    rm.mutex.Lock()
    defer rm.mutex.Unlock()
    peer, exists := rm.peers[id]
    if !exists {
        peer = &Peer{ID: id, ReputationScore: 0, Attempts: 0}
        rm.peers[id] = peer
    }
    peer.Attempts++
    if peer.Attempts > rm.maxRetries {
        rm.BlockPeer(id)
    }
}

// HashPeerID hashes the peer ID for consistent peer identification.
func HashPeerID(id string) string {
    hasher := sha256.New()
    hasher.Write([]byte(id))
    return hex.EncodeToString(hasher.Sum(nil))
}
