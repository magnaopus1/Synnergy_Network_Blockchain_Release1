package blockchain_peer_flooding_attack_security

import (
	"time"
	"net"
	"sync"
	"log"
)

// TrafficPattern stores data related to traffic patterns.
type TrafficPattern struct {
	PeerIP      net.IP
	Timestamp   time.Time
	DataVolume  int64
	ConnectionAttempts int
}

// TrafficAnalyzer performs real-time monitoring and analysis of network traffic.
type TrafficAnalyzer struct {
	Patterns      map[string][]TrafficPattern
	Mutex         sync.Mutex
	AlertChannel  chan string
	PatternWindow time.Duration
	Threshold     int64
}

// NewTrafficAnalyzer initializes a TrafficAnalyzer.
func NewTrafficAnalyzer(patternWindow time.Duration, threshold int64) *TrafficAnalyzer {
	return &TrafficAnalyzer{
		Patterns:      make(map[string][]TrafficPattern),
		AlertChannel:  make(chan string, 100),
		PatternWindow: patternWindow,
		Threshold:     threshold,
	}
}

// MonitorTraffic continuously monitors network traffic.
func (ta *TrafficAnalyzer) MonitorTraffic(peerIP net.IP, dataVolume int64) {
	ta.Mutex.Lock()
	defer ta.Mutex.Unlock()

	patterns, exists := ta.Patterns[peerIP.String()]
	if !exists {
		patterns = []TrafficPattern{}
	}

	// Add new traffic data
	patterns = append(patterns, TrafficPattern{
		PeerIP:     peerIP,
		Timestamp:  time.Now(),
		DataVolume: dataVolume,
	})

	// Filter patterns within the time window
	validPatterns := ta.filterPatterns(patterns)
	ta.Patterns[peerIP.String()] = validPatterns

	// Check for abnormal patterns
	if ta.isFlooding(validPatterns) {
		ta.AlertChannel <- peerIP.String()
		log.Printf("Flooding detected from peer: %s", peerIP.String())
	}
}

// filterPatterns filters traffic patterns based on the defined time window.
func (ta *TrafficAnalyzer) filterPatterns(patterns []TrafficPattern) []TrafficPattern {
	var filteredPatterns []TrafficPattern
	for _, pattern := range patterns {
		if time.Since(pattern.Timestamp) <= ta.PatternWindow {
			filteredPatterns = append(filteredPatterns, pattern)
		}
	}
	return filteredPatterns
}

// isFlooding checks if the given traffic patterns indicate a flooding attempt.
func (ta *TrafficAnalyzer) isFlooding(patterns []TrafficPattern) bool {
	var totalDataVolume int64
	var totalConnections int

	for _, pattern := range patterns {
		totalDataVolume += pattern.DataVolume
		totalConnections += pattern.ConnectionAttempts
	}

	return totalDataVolume > ta.Threshold
}

// RespondToFlooding handles the mitigation response for detected flooding attacks.
func (ta *TrafficAnalyzer) RespondToFlooding() {
	for peerIP := range ta.AlertChannel {
		// Example response: log the incident and add further mitigation actions
		log.Printf("Mitigating flooding attack from peer: %s", peerIP)
		// Further actions can include rate limiting, banning, or notifying network admins
	}
}
