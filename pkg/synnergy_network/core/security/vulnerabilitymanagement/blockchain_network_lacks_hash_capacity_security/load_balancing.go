package blockchain_network_lacks_hash_capacity_security

import (
	"errors"
	"log"
	"sync"
	"time"
)

// LoadBalancer struct to manage the distribution of work across nodes
type LoadBalancer struct {
	nodes                map[string]*Node
	maxLoadPerNode       float64
	alertThreshold       float64
	rebalancingInterval  time.Duration
	lock                 sync.Mutex
	alertCallback        func(string)
}

// Node struct to represent a node in the network
type Node struct {
	ID       string
	Load     float64
	IsOnline bool
}

// NewLoadBalancer initializes a new load balancer
func NewLoadBalancer(maxLoadPerNode, alertThreshold float64, rebalancingInterval time.Duration, alertCallback func(string)) *LoadBalancer {
	return &LoadBalancer{
		nodes:               make(map[string]*Node),
		maxLoadPerNode:      maxLoadPerNode,
		alertThreshold:      alertThreshold,
		rebalancingInterval: rebalancingInterval,
		alertCallback:       alertCallback,
	}
}

// AddNode adds a new node to the load balancer
func (lb *LoadBalancer) AddNode(id string) error {
	lb.lock.Lock()
	defer lb.lock.Unlock()

	if _, exists := lb.nodes[id]; exists {
		return errors.New("node already exists")
	}

	lb.nodes[id] = &Node{ID: id, Load: 0, IsOnline: true}
	return nil
}

// RemoveNode removes a node from the load balancer
func (lb *LoadBalancer) RemoveNode(id string) error {
	lb.lock.Lock()
	defer lb.lock.Unlock()

	if _, exists := lb.nodes[id]; !exists {
		return errors.New("node does not exist")
	}

	delete(lb.nodes, id)
	return nil
}

// UpdateNodeLoad updates the load of a specific node
func (lb *LoadBalancer) UpdateNodeLoad(id string, load float64) error {
	lb.lock.Lock()
	defer lb.lock.Unlock()

	node, exists := lb.nodes[id]
	if !exists {
		return errors.New("node does not exist")
	}

	node.Load = load
	if node.Load > lb.maxLoadPerNode {
		lb.sendAlert("Node " + id + " is overloaded")
	}
	return nil
}

// BalanceLoad redistributes the load among available nodes
func (lb *LoadBalancer) BalanceLoad() {
	lb.lock.Lock()
	defer lb.lock.Unlock()

	var totalLoad float64
	var onlineNodes []*Node

	for _, node := range lb.nodes {
		if node.IsOnline {
			onlineNodes = append(onlineNodes, node)
			totalLoad += node.Load
		}
	}

	if len(onlineNodes) == 0 {
		lb.sendAlert("No online nodes available for load balancing")
		return
	}

	averageLoad := totalLoad / float64(len(onlineNodes))
	for _, node := range onlineNodes {
		node.Load = averageLoad
		if node.Load > lb.maxLoadPerNode {
			lb.sendAlert("Node " + node.ID + " exceeds maximum load after balancing")
		}
	}
}

// MonitorNodes continuously monitors the nodes and balances the load
func (lb *LoadBalancer) MonitorNodes() {
	ticker := time.NewTicker(lb.rebalancingInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			lb.BalanceLoad()
		}
	}
}

// sendAlert sends an alert message using the provided callback function
func (lb *LoadBalancer) sendAlert(message string) {
	log.Println("ALERT:", message)
	if lb.alertCallback != nil {
		lb.alertCallback(message)
	}
}
