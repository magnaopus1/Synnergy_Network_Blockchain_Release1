package blockchain_network_lacks_hash_capacity_security

import (
    "log"
    "sync"
    "time"
    "errors"
    "sync/atomic"
)

// HashCapacityManager manages the hash capacity and scaling solutions
type HashCapacityManager struct {
    currentCapacity     float64
    targetCapacity      float64
    capacityIncrement   float64
    checkInterval       time.Duration
    scalingMutex        sync.Mutex
    isScalingInProgress int32
    alertChannel        chan string
}

// NewHashCapacityManager initializes a new HashCapacityManager
func NewHashCapacityManager(initialCapacity, targetCapacity, capacityIncrement float64, checkInterval time.Duration) *HashCapacityManager {
    return &HashCapacityManager{
        currentCapacity:   initialCapacity,
        targetCapacity:    targetCapacity,
        capacityIncrement: capacityIncrement,
        checkInterval:     checkInterval,
        alertChannel:      make(chan string, 100),
    }
}

// MonitorAndScale monitors the hash rate and scales the capacity as needed
func (hcm *HashCapacityManager) MonitorAndScale(getCurrentHashRate func() (float64, error)) {
    ticker := time.NewTicker(hcm.checkInterval)
    for range ticker.C {
        hashRate, err := getCurrentHashRate()
        if err != nil {
            log.Println("Error getting current hash rate:", err)
            continue
        }
        hcm.evaluateAndScale(hashRate)
    }
}

// evaluateAndScale evaluates the current hash rate and scales the capacity if needed
func (hcm *HashCapacityManager) evaluateAndScale(currentHashRate float64) {
    if currentHashRate < hcm.targetCapacity && atomic.CompareAndSwapInt32(&hcm.isScalingInProgress, 0, 1) {
        go hcm.scaleUp()
    } else if currentHashRate > hcm.targetCapacity*1.2 && atomic.CompareAndSwapInt32(&hcm.isScalingInProgress, 0, 1) {
        go hcm.scaleDown()
    }
}

// scaleUp scales up the hash capacity
func (hcm *HashCapacityManager) scaleUp() {
    hcm.scalingMutex.Lock()
    defer hcm.scalingMutex.Unlock()
    defer atomic.StoreInt32(&hcm.isScalingInProgress, 0)

    log.Println("Scaling up hash capacity...")
    hcm.currentCapacity += hcm.capacityIncrement
    log.Printf("New hash capacity: %.2f\n", hcm.currentCapacity)
    hcm.alertChannel <- "Hash capacity scaled up to: " + formatFloat(hcm.currentCapacity)
}

// scaleDown scales down the hash capacity
func (hcm *HashCapacityManager) scaleDown() {
    hcm.scalingMutex.Lock()
    defer hcm.scalingMutex.Unlock()
    defer atomic.StoreInt32(&hcm.isScalingInProgress, 0)

    log.Println("Scaling down hash capacity...")
    hcm.currentCapacity -= hcm.capacityIncrement
    log.Printf("New hash capacity: %.2f\n", hcm.currentCapacity)
    hcm.alertChannel <- "Hash capacity scaled down to: " + formatFloat(hcm.currentCapacity)
}

// formatFloat formats a float value to string
func formatFloat(value float64) string {
    return fmt.Sprintf("%.2f", value)
}

// GetAlertChannel returns the alert channel
func (hcm *HashCapacityManager) GetAlertChannel() <-chan string {
    return hcm.alertChannel
}

// main function for demonstration purposes
func main() {
    initialCapacity := 100.0
    targetCapacity := 200.0
    capacityIncrement := 50.0
    checkInterval := 10 * time.Second

    hcm := NewHashCapacityManager(initialCapacity, targetCapacity, capacityIncrement, checkInterval)
    go hcm.MonitorAndScale(func() (float64, error) {
        // Simulate getting the current hash rate
        // This should be replaced with actual logic to retrieve hash rate
        return 150.0, nil
    })

    for alert := range hcm.GetAlertChannel() {
        log.Println("ALERT:", alert)
    }
}
