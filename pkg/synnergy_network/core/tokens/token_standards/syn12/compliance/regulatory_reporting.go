package compliance

import (
	"errors"
	"fmt"
	"os"
	"time"
)

// ReportType defines the types of regulatory reports that can be generated.
type ReportType string

const (
	// TransactionReport includes detailed information about transactions.
	TransactionReport ReportType = "TRANSACTION"

	// KYCReport includes Know Your Customer (KYC) compliance details.
	KYCReport ReportType = "KYC"

	// AMLReport includes Anti-Money Laundering (AML) compliance details.
	AMLReport ReportType = "AML"

	// AuditReport includes information relevant to financial audits.
	AuditReport ReportType = "AUDIT"
)

// RegulatoryReport represents a single regulatory report.
type RegulatoryReport struct {
	Timestamp   time.Time  // Time when the report was generated
	Type        ReportType // Type of the report
	Content     string     // Report content or data
	GeneratedBy string     // Identifier of the system or person who generated the report
}

// RegulatoryReportingManager handles the generation and management of regulatory reports.
type RegulatoryReportingManager struct {
	ReportDirectory string // Directory where reports are stored
}

// NewRegulatoryReportingManager creates a new RegulatoryReportingManager.
func NewRegulatoryReportingManager(directory string) (*RegulatoryReportingManager, error) {
	if directory == "" {
		return nil, errors.New("report directory cannot be empty")
	}
	// Ensure the directory exists
	if _, err := os.Stat(directory); os.IsNotExist(err) {
		if err := os.Mkdir(directory, 0755); err != nil {
			return nil, fmt.Errorf("failed to create report directory: %w", err)
		}
	}
	return &RegulatoryReportingManager{ReportDirectory: directory}, nil
}

// GenerateReport generates a regulatory report of the specified type and content.
func (rrm *RegulatoryReportingManager) GenerateReport(reportType ReportType, content, generatedBy string) (*RegulatoryReport, error) {
	if reportType == "" || content == "" || generatedBy == "" {
		return nil, errors.New("report type, content, and generated by fields must not be empty")
	}

	report := &RegulatoryReport{
		Timestamp:   time.Now(),
		Type:        reportType,
		Content:     content,
		GeneratedBy: generatedBy,
	}

	fileName := fmt.Sprintf("%s/%s_%d.txt", rrm.ReportDirectory, report.Type, report.Timestamp.Unix())
	file, err := os.Create(fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to create report file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(fmt.Sprintf("Report Type: %s\nGenerated By: %s\nTimestamp: %s\n\n%s\n", report.Type, report.GeneratedBy, report.Timestamp.Format(time.RFC3339), report.Content)); err != nil {
		return nil, fmt.Errorf("failed to write report content: %w", err)
	}

	return report, nil
}

// RetrieveReport retrieves a regulatory report based on its type and timestamp.
func (rrm *RegulatoryReportingManager) RetrieveReport(reportType ReportType, timestamp time.Time) (*RegulatoryReport, error) {
	fileName := fmt.Sprintf("%s/%s_%d.txt", rrm.ReportDirectory, reportType, timestamp.Unix())
	fileContent, err := os.ReadFile(fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to read report file: %w", err)
	}

	return &RegulatoryReport{
		Timestamp: timestamp,
		Type:      reportType,
		Content:   string(fileContent),
	}, nil
}

// DeleteReport deletes a regulatory report based on its type and timestamp.
func (rrm *RegulatoryReportingManager) DeleteReport(reportType ReportType, timestamp time.Time) error {
	fileName := fmt.Sprintf("%s/%s_%d.txt", rrm.ReportDirectory, reportType, timestamp.Unix())
	if err := os.Remove(fileName); err != nil {
		return fmt.Errorf("failed to delete report file: %w", err)
	}
	return nil
}
