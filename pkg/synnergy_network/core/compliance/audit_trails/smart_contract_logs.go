package audit_trails

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"go.uber.org/zap"
)

// SmartContractLog represents a log entry generated by a smart contract
type SmartContractLog struct {
	ContractAddress string        `json:"contract_address"`
	EventName       string        `json:"event_name"`
	EventData       string        `json:"event_data"`
	Timestamp       time.Time     `json:"timestamp"`
	Hash            string        `json:"hash"`
}

// SmartContractLogger is responsible for logging smart contract events
type SmartContractLogger struct {
	Logs   []SmartContractLog
	mutex  sync.Mutex
	logger *zap.Logger
}

// NewSmartContractLogger creates a new instance of SmartContractLogger
func NewSmartContractLogger(logger *zap.Logger) *SmartContractLogger {
	return &SmartContractLogger{
		Logs:   []SmartContractLog{},
		logger: logger,
	}
}

// LogEvent logs a new smart contract event
func (scl *SmartContractLogger) LogEvent(contractAddress, eventName, eventData string) {
	scl.mutex.Lock()
	defer scl.mutex.Unlock()

	timestamp := time.Now()
	hash := sha256.New()
	hash.Write([]byte(contractAddress + eventName + eventData + timestamp.String()))
	eventHash := hex.EncodeToString(hash.Sum(nil))

	log := SmartContractLog{
		ContractAddress: contractAddress,
		EventName:       eventName,
		EventData:       eventData,
		Timestamp:       timestamp,
		Hash:            eventHash,
	}

	scl.Logs = append(scl.Logs, log)
	scl.logger.Info("Smart Contract Event Logged", zap.Any("log", log))
}

// GetLogs returns the smart contract logs
func (scl *SmartContractLogger) GetLogs() []SmartContractLog {
	scl.mutex.Lock()
	defer scl.mutex.Unlock()
	return scl.Logs
}

// SmartContractDrivenAuditLog represents an audit log entry generated by smart contracts
type SmartContractDrivenAuditLog struct {
	AuditTrail   *AuditTrail
	SCLogger     *SmartContractLogger
	mutex        sync.Mutex
	complianceLogger *logrus.Logger
}

// NewSmartContractDrivenAuditLog creates a new instance of SmartContractDrivenAuditLog
func NewSmartContractDrivenAuditLog(auditTrail *AuditTrail, scLogger *SmartContractLogger) *SmartContractDrivenAuditLog {
	logger := logrus.New()
	logger.SetFormatter(&logrus.JSONFormatter{})
	logger.SetLevel(logrus.InfoLevel)
	return &SmartContractDrivenAuditLog{
		AuditTrail:   auditTrail,
		SCLogger:     scLogger,
		complianceLogger: logger,
	}
}

// CaptureAuditLog captures audit logs from smart contract events
func (scal *SmartContractDrivenAuditLog) CaptureAuditLog() {
	scal.mutex.Lock()
	defer scal.mutex.Unlock()

	scLogs := scal.SCLogger.GetLogs()
	for _, log := range scLogs {
		auditLog := AuditLog{
			TransactionID:   log.Hash,
			TransactionType: "SmartContractEvent",
			Participant:     log.ContractAddress,
			Details:         log.EventName + ": " + log.EventData,
			Timestamp:       log.Timestamp,
			Hash:            log.Hash,
		}
		scal.AuditTrail.AddLog(auditLog)
		scal.complianceLogger.WithFields(logrus.Fields{
			"transaction_id":   auditLog.TransactionID,
			"transaction_type": auditLog.TransactionType,
			"participant":      auditLog.Participant,
			"details":          auditLog.Details,
			"timestamp":        auditLog.Timestamp,
			"hash":             auditLog.Hash,
		}).Info("Audit log captured from smart contract event")
	}
}

// GenerateAuditReport generates a report based on smart contract-driven audit logs
func (scal *SmartContractDrivenAuditLog) GenerateAuditReport() ([]byte, error) {
	scal.mutex.Lock()
	defer scal.mutex.Unlock()

	logs := scal.AuditTrail.GetLogs()
	report, err := json.Marshal(logs)
	if err != nil {
		scal.complianceLogger.Error("Failed to generate audit report from smart contract logs", err)
		return nil, err
	}
	return report, nil
}
